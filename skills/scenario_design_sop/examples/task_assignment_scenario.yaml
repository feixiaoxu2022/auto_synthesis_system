# 智能任务分配场景统一配置 v2.0
# 基于约束明确的世界知识规则执行框架

scenario_name: "intelligent_task_assignment"
domain: "scheduling"
scenario_type: "constraint_based_assignment"  # 约束驱动的分配场景
complexity_level: "medium"

# 实体定义 - 明确的资源调度实体
entities:
  workers:
    description: "工作人员实体（工时管理版）"
    primary_key: "worker_id" 
    attributes:
      worker_id: {type: "string", description: "工作人员ID"}
      worker_name: {type: "string", description: "工作人员姓名"}
      email: {type: "string", description: "工作人员邮箱地址"}
      capabilities: {type: "array", description: "能力标签列表，如['技术支持','数据分析','客户服务']"}
      current_workload_hours: {type: "float", description: "当前工作负载总工时(小时)，最大容量40小时"}
      availability_status: {type: "string", enum: ["available", "busy", "offline"], description: "可用状态"}
      experience_level: {type: "string", enum: ["junior", "intermediate", "senior"], description: "经验等级"}
      last_assignment_time: {type: "string", description: "最近分配时间"}
      team_id: {type: "string", enum: ["frontend_team", "backend_team", "qa_team", "devops_team", "design_team"], description: "所属团队标识，支持团队通信和协作"}

  tasks:
    description: "任务实体（工时管理版）" 
    primary_key: "task_id"
    attributes:
      task_id: {type: "string", description: "任务ID"}
      task_title: {type: "string", description: "任务标题"}
      task_description: {type: "string", description: "任务描述"}
      required_capabilities: {type: "array", description: "所需能力标签"}
      required_hours: {type: "float", description: "预计工时需求(小时)"}
      urgency_level: {type: "integer", description: "紧急程度 1-10 (10最紧急)"}
      complexity_score: {type: "integer", description: "复杂度评分 1-10"}
      deadline: {type: "string", description: "截止时间", nullable: true}
      created_time: {type: "string", description: "创建时间"}
      status: {type: "string", enum: ["pending", "assigned", "in_progress", "completed"], description: "任务状态"}
      dependencies: {type: "array", description: "依赖的任务ID列表(最多一层依赖)", nullable: true}
      assigned_worker_id: {type: "string", description: "分配的工作人员ID (null=未分配, worker_id=已分配)", nullable: true}
      assignment_time: {type: "string", description: "分配时间", nullable: true}
      assignment_rationale: {type: "string", description: "分配理由", nullable: true}

# 基于世界知识的通用分配规则（单一明确规则）
business_rules:
  universal_assignment_rule:
    description: "智能任务分配 - 通用的任务分配原则"
    trigger_conditions:
      task:
        status: "pending"
    expected_outcome:
      - "按照分配原则为待分配任务选择合适的人员并完成分配"
    task_processing_order:
      description: "任务处理顺序规则 - 确保分配结果的唯一性和可预测性"
      dependency_tasks: "有依赖关系的任务必须等待其依赖任务完成后才能处理"
      independent_tasks: "无依赖关系的任务按以下明确优先级顺序处理"
      dependency_activation_logic: "当依赖任务完成后，被激活的依赖任务立即按其优先级插入处理队列，与剩余的无依赖任务在同一队列中按优先级竞争处理顺序"
      priority_rules:
        primary: "按urgency_level降序排列 (10 > 9 > 8 > ... > 1)"
        secondary: "urgency_level相同时，按complexity_score降序排列 (10 > 9 > 8 > ... > 1)"
        uniqueness_requirement: "所有任务的(urgency_level, complexity_score)组合必须唯一，确保在任何时刻队列中都不会出现优先级相同的任务，无论是否有依赖关系"
        mixed_queue_principle: "依赖任务一旦被激活，与无依赖任务在统一优先级队列中处理，严格按(urgency_level, complexity_score)排序"
      processing_sequence_example:
        - "task_A: urgency=10, complexity=8 → 第1个处理"
        - "task_B: urgency=10, complexity=7 → 第2个处理" 
        - "task_C: urgency=9, complexity=10 → 第3个处理"
        - "task_D: urgency=9, complexity=9 → 第4个处理"
        - "dependency_example: task_E依赖task_C，当task_C完成后，task_E立即按其优先级插入队列"
      agent_visibility: "Agent可以完全预测任务处理顺序，无隐藏规则，依赖任务激活后的处理顺序完全由其优先级决定"
    assignment_principles:
      basic_requirements:
        - "人员状态必须为available（可用状态）"
        - "人员技能必须完全覆盖任务要求（worker.capabilities完全包含task.required_capabilities）"
      priority_logic:
        normal_tasks: "当任务为常规任务（urgency_level<8且complexity_score<7）时，在满足基本要求的候选人中，优先选择当前工作负载最低的人员（current_workload_hours最小）"
        urgent_tasks: "当任务紧急（urgency_level≥8）时，在满足基本要求的候选人中优先选择当前工作负载最低的人员（快速响应），负载相同时选择经验较高的"
        complex_tasks: "当任务复杂（complexity_score≥7）时，在满足基本要求的候选人中优先选择经验等级为senior的人员，多个senior中选择负载较低的"
        urgent_and_complex: "当任务既紧急又复杂（urgency≥8且complexity≥7）时，优先选择经验最高的人员，经验相同时选择负载最低的"
        dependent_tasks: "当任务有依赖关系（dependencies非空）且依赖任务状态为pending时，应先为依赖任务分配人员，然后再为当前任务分配人员"
      assignment_execution:
        - "更新任务状态为assigned"
        - "设置assigned_worker_id为选中人员ID"
        - "记录assignment_time为当前时间"
        - "将任务的required_hours加到分配人员的current_workload_hours上"
        - "在assignment_rationale中说明分配理由（如能力匹配、负载考虑、紧急处理、复杂度匹配、依赖优先等）"
    success_criteria:
      - "选择的worker.availability_status为available"
      - "选择的worker.capabilities与task.required_capabilities有交集"
      - "分配逻辑符合对应场景的优先级原则"
      - "task.status更新为assigned"
      - "分配人员的current_workload_hours正确增加了task.required_hours"
      - "assignment_rationale包含合理的分配依据说明"
    sample_generation:
      query_templates:
        - "请帮忙分配一下待处理的任务"
        - "有一些任务需要安排，请分配给合适的工作人员"  
        - "待分配任务需要处理，请选择合适的人员"
        - "能帮忙给待处理任务分配合适的负责人吗"
        - "有任务需要分配，请安排相关人员处理"
        - "请根据任务要求选择合适的工作人员进行分配"
        - "需要为待处理任务找合适的人来负责，请分配"
        - "有任务需要分配，请安排合适的人员处理"
        - "请帮忙安排一下待处理任务的负责人员"
        - "根据任务特点，请分配给最合适的工作人员"
      agent_responsibility: "根据分配原则，综合考虑人员可用性、技能匹配、工作负载、任务特性等因素进行最优分配"
      expected_outcome_type: "principle_based_assignment"
      data_constraints:
        ensure_available_workers: "至少1个availability_status为available的worker"
        ensure_capability_match: "至少1个worker的capabilities与task.required_capabilities有交集"
        ensure_workload_variety: "available匹配worker的current_workload_hours有差异"

# 映射关系配置（简化为单一规则）
rule_execution_mapping:
  universal_assignment_rule:
    scenario_type: "principle_based_assignment"
    method_name: "_calculate_assignment_logic"
    expected_outcome_type: "principle_based_assignment"

checker_type_mapping:
  assignment_created: "create_operation_verified"
  task_status_updated: "entity_attribute_equals" 
  capability_match_verified: "tool_called_with_params"  # 简化为验证工具调用
  experience_level_prioritized: "entity_attribute_equals"  # 验证选择的worker经验等级
  workload_updated_correctly: "entity_attribute_equals"  # 验证分配人员的工作负载正确增加(浮点数精度处理)
  capacity_utilization_optimized: "entity_attribute_equals"  # 验证分配后的容量利用率
  
# 浮点数比较配置
float_comparison_config:
  precision_tolerance: 0.01  # 浮点数比较容差：±0.01小时
  workload_rounding: 2       # 工作负载小时数保留2位小数
  validation_method: "rounded_comparison"  # 使用四舍五入后比较，避免浮点精度问题

scenario_type_mapping:
  principle_based_assignment: "基于原则的智能分配"

# 运行时配置
runtime_config:
  system_time: "2025-07-22T14:00:00Z"
  timezone: "Asia/Shanghai" 
  current_date_description: "今天是2025年7月22日，当前时间是14:00"

# MCP服务配置
mcp_service_config:
  service_name: "intelligent_task_service"
  service_description: "智能任务分配服务，提供任务分配相关的CRUD操作"
  service_endpoint: "http://127.0.0.1:8402/mcp"

# 样本生成配置
sample_generation:
  sample_count: 15
  diversity_requirements:
    - 覆盖常规负载优先分配场景
    - 包含紧急任务优先经验的分配场景  
    - 包含复杂任务优先senior人员的分配场景
    - 测试依赖任务的优先分配逻辑
    - 验证各种任务特性组合的分配决策
  
# 数据约束 - 基于约束规则的场景要求（精简版）
business_constraints:
  worker_constraints:
    min_workers: 4
    max_workers: 8
    capability_distribution:
      技术支持: "至少2人"
      客户服务: "至少2人" 
      数据分析: "至少1人"
      项目管理: "至少1人"
    experience_distribution: "30% junior, 40% intermediate, 30% senior"
    availability_distribution: "70% available, 20% busy, 10% offline"
    capacity_utilization_scenarios:
      light_load: "0.0-0.3 (30%的available workers)"
      moderate_load: "0.3-0.7 (50%的available workers)"
      heavy_load: "0.7-0.95 (20%的available workers)"
  task_constraints:
    urgency_distribution: "20% high urgency (8-10), 50% medium (4-7), 30% low (1-3)"
    complexity_distribution: "25% complex (7-10), 50% medium (4-6), 25% simple (1-3)"
    capability_requirement_variety: "确保覆盖所有定义的能力标签"
    deadline_scenarios: "30%的任务有明确截止时间"
    task_type_distribution: "各任务类型均匀分布，确保覆盖所有枚举值"
    dependency_scenarios: "30%的任务有依赖关系，最多一层依赖深度"
    processing_order_uniqueness: "所有无依赖任务的(urgency_level, complexity_score)组合必须唯一，确保任务处理顺序完全确定"
  assignment_constraints:
    assignment_response_time: "30秒内完成分配决策"
    rationale_requirement: "所有分配必须包含清晰的reasoning"
    capacity_respect: "不向capacity_utilization≥1.0的worker分配任务"
  dependency_constraints:
    max_dependency_depth: 1  # 最多一层依赖
    dependency_ratio: 0.2    # 20%任务有依赖
    time_logical_consistency: "依赖任务created_time必须早于当前任务"
    relationship_validation: "所有dependencies中的task_id必须存在于数据中"