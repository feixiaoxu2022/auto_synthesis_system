# 五种难度提升方法详解

## 核心挑战

Agent评测的核心矛盾：**如何在保证可验证性的前提下，设计出高难度的评测任务？**

关键约束：

- **可验证**：必须有客观标准，不依赖LLM-as-Judge
- **高难度**：能有效区分不同模型的能力水平
- **真实性**：源自真实场景，不是为测试而测试

---

## 方法1：复杂业务规则

### 设计原理

在system prompt中设计大量条件分支和约束规则，通过final_state验证业务规则是否被正确执行。

**复杂性体现在**：system prompt包含大量条件分支、约束规则和业务逻辑

### 关键设计维度

复杂业务规则的难度来源于多个维度的叠加：

| 维度 | 说明 | 难度贡献 |
|-----|------|---------|
| **多因素决策矩阵** | 结果由多个变量组合决定 | 条件分支爆炸 |
| **实体属性体系** | 用户/对象有多层属性影响规则 | 需要正确获取和组合 |
| **计算逻辑** | 涉及数值计算、时间推算 | 计算错误直接失败 |
| **状态更新要求** | 操作后需要更新多个关联状态 | 遗漏任一更新则失败 |
| **优先级排序** | 多个候选需要按规则排序选择 | 排序逻辑复杂 |

---

### 示例1：智能任务分配（Intelligent Task Assignment）

**场景**：将工单分配给最合适的客服人员

**规则复杂性设计**：

```
1. 多因素匹配规则：
   - 技能匹配：工单类型 → 需要的技能 → 客服具备的技能
   - 语言匹配：客户语言偏好 → 客服语言能力
   - 负载均衡：当前工单数 < 最大承载量

2. 优先级排序规则：
   - 紧急度：P0 > P1 > P2
   - 客户等级：VIP > 普通
   - 等待时间：超过SLA阈值优先

3. 状态更新要求（叠加难度）：
   - 分配后：更新工单状态为"已分配"
   - 分配后：更新客服当前工单数+1
   - 分配后：记录分配时间戳
   - 分配后：发送通知给客服
```

**验证点**：
- 匹配结果是否正确（技能、语言、负载都满足）
- 优先级排序是否正确
- 所有状态更新是否完成

---

### 示例2：共享单车（Bikeshare）

**场景**：处理用户的骑行、还车、异常上报等请求

**规则复杂性设计**：

```
1. 多层用户体系：
   - 用户等级：普通/银卡/金卡/黑卡
   - 信用分：0-100分，影响可用功能
   - 押金状态：已缴/未缴/免押金资格

2. 分层规则体系：
   Layer 1 - 资格校验：
     - 信用分 < 60 → 禁止骑行
     - 未缴押金且无免押资格 → 禁止骑行

   Layer 2 - 费用计算：
     - 基础费用 = 时长 × 单价
     - 等级折扣：银卡9折/金卡8折/黑卡7折
     - 信用加成：信用分>90额外95折

   Layer 3 - 异常处理：
     - 超区还车 → 收取调度费
     - 车辆损坏 → 根据损坏程度扣信用分
     - 举报违停 → 奖励信用分

3. 状态联动更新：
   - 骑行结束 → 更新用户余额
   - 骑行结束 → 更新用户信用分
   - 骑行结束 → 更新车辆位置
   - 骑行结束 → 更新车辆状态
```

**子需求多样性**：用户体系 × 场景类型 = 大量测试组合
- 金卡用户正常还车
- 低信用分用户尝试骑行（应拒绝）
- 超区还车的费用计算
- 举报违停后的信用分更新

---

### 示例3：办公行政（OA）

**场景**：处理请假、出差、报销等行政申请

**规则复杂性设计**：

```
1. 时间推算规则：
   - 工作日计算：排除周末和法定节假日
   - 请假天数：跨月/跨年需要分段计算
   - 提前申请要求：请假≥3天需提前5个工作日

2. 费用计算规则：
   - 出差补贴：城市等级 × 天数 × 职级系数
   - 住宿限额：一线城市500/二线350/三线250
   - 交通标准：职级决定可选交通方式

3. 余额扣减规则：
   - 年假优先级：调休 > 年假 > 事假
   - 跨年度处理：当年余额不足时是否可预支
   - 扣减时机：审批通过时扣减 vs 申请时冻结

4. 审批链规则：
   - 金额阈值：<1000直属审批/>1000部门审批/>5000财务审批
   - 职级跨越：不能越级审批
   - 代理审批：审批人请假时的代理机制
```

**验证点**：
- 天数计算是否正确（排除节假日）
- 费用计算是否符合标准
- 余额扣减是否按优先级执行
- 审批链是否正确生成

---

### 示例4：广告投放（Ad Campaign）

**场景**：为广告主创建投放计划

**规则复杂性设计**：

```
1. 多因素决策矩阵：
   现金流状况 × 团队经验 → ROI目标

   |          | 新手团队 | 中级团队 | 专家团队 |
   |----------|---------|---------|---------|
   | 资金紧张 | 1.8     | 2.0     | 2.2     |
   | 资金稳定 | 2.0     | 2.8     | 3.5     |
   | 资金充裕 | 2.5     | 3.0     | 3.8     |

2. 渠道约束规则：
   - 预算分配：单渠道不超过总预算40%
   - 渠道组合：至少2个渠道，最多5个
   - 渠道适配：产品类型决定可选渠道

3. 预算计算规则：
   - 日预算 = 总预算 / 投放天数
   - 渠道预算 = 日预算 × 渠道权重
   - 保底消耗 = 渠道最低起投额
```

**验证点**：
- ROI目标是否根据矩阵正确设定
- 渠道组合是否满足约束
- 预算分配计算是否正确

---

### 设计要点总结

1. **规则层次化**：设计多层规则体系，每层解决不同问题
2. **因素组合化**：多个因素组合决定结果，而非单一条件
3. **计算精确化**：涉及数值、时间计算时，精确度是硬性要求
4. **状态联动化**：一个操作触发多个状态更新，遗漏则失败
5. **实体属性化**：用户/对象有丰富属性，影响规则分支

---

### 设计来源：算法映射法

**核心思路**：选择成熟算法作为规则设计的骨架，将算法问题包装成业务场景。

**为什么有效**：

```
传统算法测试：
  输入：一个约束满足问题的形式化描述
  要求：写代码求解
  → LLM可能很强（训练数据中有大量算法代码）

场景化算法应用：
  输入：一个任务分配的业务场景
  要求：通过tool call获取数据，做出符合约束的分配决策
  → 需要复合能力：理解业务 + 正确调tool + 应用算法逻辑 + 处理边界
  → 难度显著提升
```

**常见算法→场景映射**：

| 算法类型 | 业务场景 | 复合难点 |
|---------|---------|---------|
| **约束满足(CSP)** | 任务分配、排班、资源调度 | 约束分散在多个tool返回中，需整合判断 |
| **背包问题** | 预算分配、广告投放、库存优化 | 价值/成本需通过tool查询并计算 |
| **优先级队列** | 工单排序、紧急调度、审批排队 | 优先级规则在prompt，数据在tool |
| **图遍历/搜索** | 审批链构建、组织架构查询 | 需递归调用tool，处理环和异常 |
| **匹配算法** | 人岗匹配、客服分配、推荐 | 多维度评分，权重隐含在业务规则中 |
| **贪心/动态规划** | 路径规划、费用最优、时间安排 | 需要多步决策，每步依赖前序结果 |
| **状态机(FSM)** | 订单流转、工单生命周期、审批状态 | 判断当前状态+触发条件→合法下一状态，拒绝非法转换 |
| **拓扑排序** | 任务依赖排期、项目计划、流程编排 | 识别依赖关系，检测循环依赖，确定执行顺序 |
| **区间调度** | 会议室预定、时间槽分配、排班表 | 时间冲突检测，最大化资源利用率 |
| **最短路径** | 物流路线、审批最短链、成本最优方案 | 动态构建图，权重来自多个tool，路径回溯 |
| **滑动窗口** | 限流控制、异常检测、移动平均 | 时间窗口内聚合计算，窗口边界处理 |
| **并查集** | 用户分组、权限继承、关系网络 | 动态合并查询，传递性关系处理 |
| **规则引擎/决策树** | 风控判断、客户分层、自动审批 | 多条件组合评估，规则优先级冲突 |

**设计流程**：

```
Step 1: 选择算法
  - 从上表选择一个与业务匹配的算法类型
  - 例：任务分配 → 约束满足问题(CSP)

Step 2: 识别核心约束
  - 硬约束：必须满足（技能匹配、时间冲突）
  - 软约束：尽量满足（负载均衡、偏好）

Step 3: 设计数据获取路径
  - 哪些约束条件需要通过tool call获取？
  - 设计合理的tool返回结构

Step 4: 包装成业务场景
  - 用业务语言描述问题，而非算法语言
  - 在system prompt中给出规则，但不点明"这是CSP问题"

Step 5: 设计验证点
  - 硬约束是否全部满足
  - 软约束的优化程度
  - 状态更新是否完整
```

**与直接考算法的区别**：

| 维度 | 直接考算法 | 算法映射法 |
|-----|-----------|-----------|
| 测试目标 | 能否实现算法 | 能否应用算法解决业务问题 |
| 输入形式 | 形式化问题描述 | 业务场景 + tool调用 |
| 数据获取 | 直接给定 | 需要通过tool call获取 |
| 约束表达 | 数学公式 | 业务规则（自然语言） |
| 能力覆盖 | 单一（编程） | 复合（理解+调用+应用+验证） |

### 适用场景

任务分配、资源调度、订单处理、费用计算、审批流程、会员体系

---

## 方法2：领域知识门槛

### 设计原理

设计需要**专业级领域知识**才能完成的任务，这些知识是"专家都知道，但外行容易忽略"的深层机制理解。

**核心特征**：
- **无法快速习得**：不是通过搜索就能解决，需要系统学习
- **隐藏难点设计**：任务描述不明说，但专业人士都知道
- **一票否决测试**：不理解这个知识点必然失败

### 设计要点

1. **识别领域"常识盲区"**：专家认为理所当然，但外行会忽略的关键点
2. **故意不完备的任务描述**：留下需要专业判断的空间
3. **设计"隐藏Boss"测试**：验证是否真正理解核心原理
4. **答案唯一明确**：可通过系统状态自动验证

### 真正的领域知识门槛示例

#### 示例1：统计计算 - 自适应拒绝采样器

| 维度 | 内容 |
|-----|------|
| **任务描述** | 实现Gilks(1992)论文中的自适应拒绝采样算法 |
| **隐藏难点** | ARS算法只适用于对数凹分布，必须检测并拒绝非对数凹输入 |
| **为什么是盲区** | 论文明确要求，但很多实现会忽略这个前置检查 |

**验证方式设计**：
```
普通测试（大多数Agent能过）：
  输入：标准正态分布 dnorm(x)
  验证：生成的样本均值≈0，标准差≈1

隐藏Boss测试（不理解原理必挂）：
  输入：双峰分布 0.5*dnorm(x,-2) + 0.5*dnorm(x,2)  ← 非对数凹！
  验证：Agent必须抛出错误或拒绝采样
  如果Agent接受了这个输入并尝试采样 → 测试失败
```

---

#### 示例2：版本控制 - Git密钥泄露清理

| 维度 | 内容 |
|-----|------|
| **任务描述** | 清理仓库中泄露的密钥，确保任何地方都找不到 |
| **隐藏难点** | 删除commit不等于删除数据，reflog和dangling objects会保留历史 |
| **为什么是盲区** | 大多数人以为git reset就能删除历史 |

**验证方式设计**：
```
普通测试：
  验证：git log中找不到包含密钥的commit

隐藏Boss测试：
  Test 1: git reflog | grep secret → 必须无输出
  Test 2: git fsck --lost-found → dangling objects中不能有密钥
  Test 3: 运行git gc后再次检查 → 物理层面真正删除

如果只删了commit但没清理reflog → Test 1失败
如果没强制gc → Test 2可能失败
```

---

#### 示例3：编译系统 - Cython扩展兼容Numpy 2.0

| 维度 | 内容 |
|-----|------|
| **任务描述** | 修复三个Cython扩展模块，使其能在Numpy 2.0下编译运行 |
| **隐藏难点** | Numpy 2.0中import_array()返回类型从void变为int |
| **为什么是盲区** | 这是API breaking change，不看release notes很难知道 |

**验证方式设计**：
```
连环测试（验证是否理解通用原理，而非只修了一个）：
  Test 1: python -c "from chelpers import ..." → 必须成功
  Test 2: python -c "from ccomplexity import ..." → 必须成功
  Test 3: python -c "from cinvariants import ..." → 必须成功

副作用测试：
  Test 4: 验证Numpy版本仍是2.0（不能降级绕过问题）
  Test 5: 原仓库的测试套件仍能通过

如果只修了一个模块 → 其他两个测试失败
如果降级Numpy版本 → Test 4失败
```

---

#### 示例4：Web安全 - XSS过滤器

| 维度 | 内容 |
|-----|------|
| **任务描述** | 实现HTML XSS过滤器，阻止恶意脚本注入 |
| **隐藏难点** | XSS攻击有数百种变体，简单的黑名单无法覆盖 |
| **为什么是盲区** | 新手只会过滤`<script>`，不知道`<ScRiPt>`、`javascript:`等变体 |

**验证方式设计**：
```
普通测试：
  输入：<script>alert(1)</script>
  验证：被过滤或转义

隐藏Boss测试（大规模攻击样本）：
  输入：数百个XSS payload变体
    - 大小写混淆: <ScRiPt>
    - 事件处理: <img onerror="...">
    - 协议注入: <a href="javascript:...">
    - 编码绕过: &#x3C;script&#x3E;
  验证：全部被阻止，一个漏过就失败

如果用黑名单实现 → 大量变体会绕过 → 测试失败
只有使用成熟库（如bleach）才能通过
```

### 与"复杂业务规则"的区别

```
错误理解（这不是领域知识门槛，只是业务流程）：
  "申请5天年假，调休余额优先扣除"
  → 这只需要理解业务规则，可以通过阅读文档快速掌握

正确理解（真正的领域知识门槛）：
  "实现自适应拒绝采样算法"
  → 需要理解对数凹性数学概念、包络构造原理、统计采样理论
  → 无法在执行时限内通过搜索学会
  → 不理解对数凹性 → 双峰分布测试必然失败
```

### 设计流程

1. **选择专业领域**：找到需要系统学习的技术领域
2. **识别关键假设**：阅读领域经典文献，找到算法/系统的核心假设
3. **设计陷阱测试**：构造违反假设的输入，专家能识别，新手会忽略
4. **验证区分度**：预估50-90%的失败率才是有效的隐藏Boss

### 适用场景

- **终端/CLI任务**：系统管理、编译构建、版本控制
- **算法实现**：统计计算、机器学习、数值优化
- **安全评测**：漏洞修复、攻击防御、配置加固

### 局限性

- **对任务设计者要求高**：需要领域专家参与设计
- **领域覆盖有限**：不是所有业务场景都有深层技术门槛
- **不适合通用生产力任务**：办公自动化等场景更适合其他方法

---

## 方法3：人类共识任务

### 设计原理

选择那些**没有客观标准答案，但人类会有较高共识**的判断类任务。

**两种形式**：
- **设计阶段共识**：答案客观可验证，但"测什么"由人类共识决定（如Memory任务）
- **评估阶段共识**：答案本身需要人类共识来判定（如回复质量评估）

### 示例1：BFCL v4 Memory Task（设计阶段共识）

**任务背景**：Agent作为客服助手，与用户进行多轮对话后，需要记住对话中的关键信息。

**设计思路**：

```
Step 1: 构造长对话历史
  - 用户（Michael）与客服进行10轮深度对话
  - 对话涵盖：产品咨询、下单、物流问题、损坏投诉、再次购买、会员咨询...
  - 对话中自然透露大量个人信息和业务细节

Step 2: 设计记忆测试问题
  问题示例：
  - "What is my first name?" → Michael
  - "How old am I?" → 35
  - "What kind of latte do I occasionally like?" → strawberry matcha
  - "Which appliance did I banish to the pantry?" → toaster oven
  - "What's my coffee instagram page?" → @coffee_creations_1237
```

**共识体现在哪里**：

```
答案验证：客观的（原文说35岁就是35岁，rule-based可验证）

共识体现在任务设计：
  - 为什么测"用户年龄"而不测"西雅图降雨量"？
  - 为什么测"instagram账号"而不测"对话中提到的每个数字"？
  → 这是设计者基于"什么信息对客服有价值"的人类共识做的选择
  → 没有算法能自动决定"应该测哪些信息点"

设计者的隐含判断：
  - 用户姓名、年龄 → 基础信息，值得测
  - 产品偏好、投诉细节 → 服务相关，值得测
  - 随口提到的天气 → 不重要，不测
```

**验证方式**：Rule-based，答案从原文直接提取，无需人工标注

---

### 示例2：任务紧急度判断（评估阶段共识）

**任务背景**：客服系统收到多个工单，需要判断处理优先级

**为什么需要人类共识**：

```
场景：同时收到3个工单

工单A：VIP客户询问产品参数（已等待10分钟）
工单B：普通客户反映订单配送延迟2天（情绪激动）
工单C：新客户咨询促销活动（首次接触）

问题：应该优先处理哪个？

→ 没有绝对正确的公式（VIP优先？情绪优先？等待时间优先？）
→ 但有经验的客服主管会有相似的判断倾向
→ 这个"判断倾向"就是需要人类标注来捕捉的共识
```

**具体评估维度**（需人类共识确定权重）：

| 维度 | 说明 | 为什么无法客观量化 |
|-----|------|------------------|
| 业务影响 | 问题不处理的后果 | "VIP流失"vs"差评"哪个更严重？ |
| 情绪风险 | 用户当前情绪状态 | "有点不满"vs"非常愤怒"边界模糊 |
| 时效性 | 问题是否有时间窗口 | 什么算"紧急"？1小时？1天？ |
| 转化价值 | 潜在商业价值 | 新客户转化vs老客户维护哪个重要？ |

**验证方式**：人类标注（10+人独立判断，≥70%选择同一优先级为共识）

---

### 两种形式对比

| 维度 | 设计阶段共识（Memory） | 评估阶段共识（质量评估） |
|-----|----------------------|------------------------|
| 答案验证 | Rule-based（原文提取） | 需要人类标注 |
| 共识体现 | 设计者决定"测什么" | 标注员决定"答案是什么" |
| 标注成本 | 低（设计时一次性决定） | 高（每个样本都需标注） |
| 适用场景 | 信息记忆、事实提取 | 质量评价、主观判断 |

### 其他适用场景

| 场景 | 共识类型 | 说明 |
|-----|---------|------|
| **信息记忆** | 设计阶段 | 测哪些信息点由设计者共识决定，答案客观可验证 |
| **优先级排序** | 评估阶段 | 多个任务/工单应该按什么顺序处理 |
| **意图消歧** | 评估阶段 | 用户模糊表达背后的真实意图是什么 |
| **风险等级** | 评估阶段 | 用户行为属于"低/中/高"哪个风险等级 |

### 设计要点

1. **区分共识类型**：先判断是设计阶段共识还是评估阶段共识
2. **设计阶段共识**：重点在任务设计，验证可以是rule-based
3. **评估阶段共识**：需要人类标注，注意成本控制
4. **问题设计要具体**：问"用户年龄是多少"而非"用户是什么样的人"

### 局限性

- **评估阶段共识成本高**：每个样本都需要多人标注
- **设计阶段共识主观性**：设计者的选择可能被质疑
- **领域依赖**：不同领域的"共识"标准不同

---

## 方法4：多轮需求变更

### 设计原理

通过多轮对话，让需求不断变化。测试Agent的上下文理解和动态调整能力。最终状态可验证。

**复杂性体现在**：多轮query/用户模拟器prompt——通过对话轮次增加和需求变更来累积上下文复杂度

### 设计要点

1. **渐进式披露信息**：不要一次性给完所有信息
2. **中途变更需求**：不只是渐进披露，而是推翻重来
3. **延长对话轮次**：复杂场景可达30-50轮
4. **最终状态可验证**：验证Agent是否正确处理了所有变更

### 信息披露节奏设计

```yaml
disclosure_pace:
  upfront: "用户一开始就给出所有信息"
  progressive: "用户逐步补充信息"
  responsive: "用户只在被问到时才回答"
  reluctant: "用户需要被多次追问才给出完整信息"
```

### 需求变更模式

```
Round 1-5: 正常业务流程
Round 7: "等等，我改主意了，xxx不要了"  → 测试取消操作
Round 9: "能不能改成xxx？"              → 测试需求变更
Round 11: "对了，再加一个xxx"           → 测试新增需求
Round 15: "算了还是按原来的来"          → 测试回退操作
```

### 适用场景

客服对话、需求收集、项目管理、任何涉及用户交互的场景

---

## 方法5：信息洋葱

### 设计原理

将关键信息分散在多个地方，需要多步推理才能找到。每一步得到的信息都是下一步的线索。**这是GAIA benchmark的核心设计思想**。

**复杂性体现在**：环境信息和tool设计——通过设计多层信息嵌套和长推理链

**核心特征**：
- **信息不直接给出**：用户给的是线索，不是答案
- **链式依赖**：Step N的输出是Step N+1的输入
- **任一步错则全错**：推理链的正确性是乘法关系

---

### GAIA的设计智慧

GAIA benchmark的核心洞察：**让题目对AI困难，同时保证答案客观唯一**

```
GAIA题目特征：
- 人类专家30分钟内可完成
- 需要3-18步推理
- 答案精确匹配验证（无需LLM-as-Judge）
- 步骤越多，模型表现越差

GAIA Level分布：
- Level 1 (3-5步): GPT-4约30%通过率
- Level 2 (5-12步): GPT-4约15%通过率
- Level 3 (10+步): GPT-4约5%通过率
```

---

### 五大设计技巧（来自GAIA）

#### 技巧1：信息源锚定

**问题**：信息可能随时间变化，导致答案不稳定

**解决**：指定精确的信息源和版本

```
❌ 查询用户的当前余额
✅ 查询用户在订单创建时刻的余额快照

❌ 获取员工信息
✅ 获取employee_id=E001在2025-07-16的在职状态
```

**业务场景应用**：
```yaml
# 在tool返回中设计时间锚点
get_employee_info:
  返回: 员工信息 + 数据快照时间

get_leave_balance:
  参数: employee_id, as_of_date  # 指定查询时点
  返回: 该时点的余额，而非"当前"余额
```

#### 技巧2：间接引用设计

**问题**：直接给出目标ID太简单

**解决**：给出关联ID，需要Agent自己关联查找

```
GAIA示例：
  题目：Finding Nemo的主角是什么鱼？这种鱼在USGS数据库的非本土发现地点邮编是？
  推理链：电影名 → 角色名 → 鱼类物种 → 数据库查询 → 邮编

Bikeshare示例：
  题目：处理订单O12345的退款
  推理链：订单ID → 查询订单 → 获取用户ID → 查询用户余额 → 计算退款 → 执行操作

  ❌ 直接给user_id
  ✅ 只给order_id，需要Agent通过订单查到user_id
```

**设计模式**：
```
给出的信息          需要查找的信息         最终目标
─────────────────────────────────────────────────
order_id      →    user_id         →    user_balance
ticket_id     →    assignee_id     →    assignee_skills
申请编号       →    申请人工号       →    申请人部门主管
```

#### 技巧3：跨实体信息拼接

**问题**：信息集中在一个实体太简单

**解决**：答案需要从多个实体拼接

```
GAIA示例：
  AI监管论文(2022) 中的图表标签词 → 在 物理社会学论文(2016) 中的含义

业务场景示例：
  判断是否可以审批：
  - 从 申请单 获取 申请金额
  - 从 申请人 获取 所属部门
  - 从 部门配置 获取 审批阈值
  - 从 审批人 获取 审批权限
  → 综合判断：金额 < min(部门阈值, 个人权限)
```

#### 技巧4：条件层层收敛

**问题**：筛选条件太少，结果不唯一

**解决**：多重约束条件，逐步收敛到唯一解

```
GAIA示例：
  在化学数据库中找到同时满足：
  - 分子量 ≤ 100 g/mol
  - 重原子数 = 6
  - 氢键受体 ≤ 1
  - 食品添加剂分类
  的化合物CID

业务场景示例：
  找到可以处理该工单的客服：
  - 技能匹配：具备"退款处理"技能
  - 语言匹配：支持用户语言（中文）
  - 负载限制：当前工单数 < 10
  - 在线状态：当前在线
  - 优先级：选择当前工单数最少的
  → 唯一结果
```

#### 技巧5：计算锚定答案

**问题**：文本类答案可能有歧义

**解决**：设计需要计算的数值答案

```
GAIA示例：
  基普乔格跑完地月距离需要多少千小时？
  → 答案是精确数值17，无歧义

业务场景示例：
  计算该用户本次骑行费用：
  - 基础费用 = 时长(分钟) × 单价
  - 等级折扣 = 基础费用 × 折扣率
  - 信用加成 = 折扣后 × (信用分>90 ? 0.95 : 1)
  → 精确数值，任一步计算错误都会导致最终结果错误
```

---

### 推理链复杂度设计

**难度递进**：

| 级别 | 推理步数 | 信息源数 | 工具调用 | 预期通过率 |
|-----|---------|---------|---------|-----------|
| 简单 | 2-4步 | 1-2个 | 2-3次 | 70-90% |
| 中等 | 5-8步 | 2-4个 | 4-6次 | 30-50% |
| 困难 | 9-12步 | 3-5个 | 7-10次 | 10-30% |
| 极难 | 12+步 | 5+个 | 10+次 | <10% |

**复杂度计算公式**：
```
难度 ≈ 步数 × 每步准确率要求 × 信息源分散度

假设每步95%准确率：
- 4步链: 0.95^4 = 81% 整体准确率
- 8步链: 0.95^8 = 66% 整体准确率
- 12步链: 0.95^12 = 54% 整体准确率
```

---

### 完整示例：OA审批场景

**用户请求**：帮我查一下工号E001的年假申请审批进度

**设计的推理链**：

```
Step 1: 查询员工信息
  输入: employee_id = "E001"
  输出: {name: "张三", department: "技术部", level: "P6"}

Step 2: 查询该员工的待审批申请
  输入: employee_id = "E001", status = "pending"
  输出: {application_id: "LA2025001", type: "annual_leave", days: 5}

Step 3: 查询申请详情
  输入: application_id = "LA2025001"
  输出: {amount_days: 5, created_at: "2025-07-10", approver_id: "E100"}

Step 4: 查询审批人信息
  输入: employee_id = "E100"
  输出: {name: "李四", position: "技术部经理", status: "on_leave"}

Step 5: 发现审批人请假，查询代理审批人
  输入: employee_id = "E100", date = "2025-07-16"
  输出: {delegate_id: "E101", delegate_name: "王五"}

Step 6: 查询代理审批人的审批权限
  输入: employee_id = "E101"
  输出: {can_approve_leave: true, max_days: 7}

Step 7: 综合判断并返回结果
  - 申请5天 < 代理人权限7天 ✓
  - 返回：申请LA2025001由王五(E101)代理审批中
```

**验证点**：
- Agent是否正确识别出审批人请假？
- Agent是否主动查询代理审批人？
- Agent是否验证代理人权限足够？
- 最终答案是否完整准确？

---

### 与其他方法的组合

**信息洋葱 + 复杂规则**：
```
推理链中嵌入业务规则判断
例：Step 4发现审批人请假 → 触发代理机制规则
```

**信息洋葱 + 多轮变更**：
```
推理链进行到一半，用户变更需求
例：Step 3后用户说"等等，我要改成请3天不是5天"
→ 需要部分回退重新推理
```

### 适用场景

审批流程、工单处理、订单查询、权限校验、多级关联查询

## 五种方法对比

| 设计方法           | 复杂性体现    | 难度来源   | 验证方式 | 成本 | 推荐程度       |
| ------------------ | ------------- | ---------- | -------- | ---- | -------------- |
| 复杂规则           | system prompt | 条件分支多 | final_state状态验证 | 低   | 基础必备       |
| 领域知识           | 任务本身 | 专家常识盲区 | 隐藏Boss测试（违反假设的输入） | 低   | 技术任务       |
| 人类共识           | 机制设计      | 共识判断   | 人工标注（10+人，70%阈值） | 高   | 资源充足时     |
| **多轮变更** | 多轮query     | 上下文累积 | final_state状态验证 | 中   | **主力** |
| **信息洋葱** | 环境+tool     | 推理链长   | 最终答案验证（任一步错则全错） | 低   | **主力** |

---

## 推荐组合策略

### 核心组合

**方法4（多轮变更）+ 方法5（信息洋葱）+ 方法1（复杂规则）**

原因：

1. 方法4测试上下文管理能力
2. 方法5测试多步推理能力
3. 方法1提供业务复杂度基础
4. 三者组合覆盖主要能力维度

### 组合应用示例

```yaml
# 一个样本同时应用多种方法
business_rules:
  # 方法1：复杂规则
  rule_approval_matrix:
    条件矩阵: 职级×金额×类型 → 审批层级

  # 方法5：信息洋葱
  required_actions:
    - 查询员工信息
    - 查询审批权限
    - 查询上级信息
    - 创建审批流程

# 方法4：多轮变更
multiturn_config:
  conversation_flow:
    - 初始请求
    - 补充信息
    - 需求变更
    - 最终确认
```

---

## 设计原则总结

### 三个必须

1. **难度要够**：能区分不同模型能力
2. **能验证**：不依赖LLM-as-Judge，有客观标准
3. **够真实**：源自真实用户需求，不是为测试而测试

### 五种方法不互斥

这五种方法可以组合使用：

- 在一个任务中同时用复杂规则+多轮变更
- 在信息洋葱中嵌入领域知识
- 用人类共识验证复杂规则的执行效果
